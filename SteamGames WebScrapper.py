# -*- coding: utf-8 -*-
"""Gabriel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PNgYP6ENhJ4Yjij8qpf4GZEIAbuf06OP

# Uma breve introdução ao Beautiful Soup 4
[Adaptado da documentação oficial](https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr/)
"""

from bs4 import BeautifulSoup
import requests
import re
import numpy as np

cookies = {'birthtime': '568022401',
           'steamCountry': 'BR%7C727076c0064c27f419883a1500b1d955',
           'Steam_Language': 'english'}

"""# **Parte da Steam**

# Função para obter diferentes atributos do jogo
"""

# A Função busca por diversos atributos de um jogo, trata esses valores
# e os retorna em forma de uma lista, seguindo a seguinte ordem:
#   0 - Data de Lançamento
#   1 - Resumo das Ánalises
#   2 - Número de Ánalises
#   3 - Desenvolvedora(s)
#   4 - Distruibuidora(s)
def get_Attributes(soup):

  analysis = 0
  n_analysis = 0

  #Busca pela data de lançamento
  date_att = soup.find('div', {'class':'date'})

  #retira a virgula da data de lançamento
  release_date = date_att.get_text().replace(',', '')

  #procura por diversas informações sobre o jogo
  infos_att = soup.find_all('div', {'class':'summary column'})

  #junta as informações em uma unica string
  infos_text = ""
  for item in infos_att:
    infos_text += item.get_text()

  #é eliminado espaçamentos das informações para limpar o texto
  infos_text = infos_text.replace('\t', '').replace('\r', '')

  attributes = []

  #a string sofre um split baseado em quebras de linha, criando uma lista
  attributes = infos_text.split('\n') 
  #em seguida é retirada qualquer string vazia da lista
  attributes = [x for x in attributes if x]

  #avalicao do jogo
  analysis = attributes[0]

  #se há avaliações, encontra o numero de avalicões totais do jogo
  if len(attributes) > 3:
    attributes[-4] = attributes[-4].replace(',', '')
    pattern = re.compile(r'[a-zA-Z0-9]+')
    n_analysis = pattern.findall(attributes[-4])
    n_analysis = n_analysis[0]

  #encontra a developer e a publisher do jogo que estão nas duas ultimas posições
  developer = attributes[-2]
  publisher = attributes[-1]

  return release_date, analysis, n_analysis, developer, publisher

"""# Função para verificar se o jogo é Indie"""

#A Função busca se o jogo é Indie, dentre os seus diferentes gêneros
#Retorna 'Sim' ou 'Não'
def get_Indie(soup):
  #procuramos os diferentes gêneros que o jogo possui
  details = soup.find('div', {'class':'details_block'}).find_all('a')

  #Em seguida verificamos se ele é um jogo indie ou não
  gender_list = ""
  for item in details:
    gender_list += item.get_text() + ' '

  #procura a substring 'Indie' dentre a lista de generos
  indie_check = gender_list.find("Indie")

  #se foi encontrada, o jogo é indie
  if indie_check != -1:
    return 'Sim' #O jogo é Indie
  else: 
    return 'Não' #O Jogo não é Indie

"""# Nova seção"""

#A Função procura o nome do jogo e
#Retorna o seu nome
def get_Name(soup):
  #encontra o nome do jogo
  game_name = soup.find('div',{'class','apphub_AppName'}).get_text()

  return game_name

"""# Função para obter Linguagens"""

#A função obtem a quantidade de linguagens que o jogo oferece suporte,
#para Interface, Dublagem e Legendas
#Retorna um vetor com a quantidade de linguagens que possuem suporte para 
#   cada elemento, seguindo a seguinte ordem:
#     0 - Iterface
#     1 - Dublagem
#     2 - Legendas
def get_Languages(soup):
  languages = [0, 0, 0]
  #encontramos a tabela de linguagens
  details = soup.find('table', {'class':'game_language_options'})
  if details:
    details = details.find_all('tr')
    #iteramos a tabela a procura de cada linha, verificando linguagem
    #ela se apresenta da forma
    # Posição: 0 - Linguagem            
    #          1 - Iterface
    #          2 - Dublagem
    #          3 - Legendas
    for item in details:
      teste = item.find_all('td')
      for i in range(1, len(teste)): # pulamos o primeiro valor do nome da Linguagem
        aux = teste[i].get_text().replace('\n', '')
        if aux != '': #verifica se há um Check ou é vazio na tabela referente a esta lingua
          languages[i-1] += 1 #somamos se há suporte para a linguagem


  return languages

"""# Função para obter o Preço"""

#A Função procura a price tag do jogo e obtem seu preço(em dólares)
#Retorna a pricetag
def get_Price(soup):

  #encontra a tag de preço e retira apenas o valor em dolares
  details = soup.find('div', {'class','game_purchase_price price'})

  # padrão para encontrar o preço do jogo na forma .

  #details = soup.find('div', {'class','discount_original_price'})
  pattern = re.compile(r'[0-9]+(.[0-9][0-9])?')
  #teste = pattern.search(details.get_text())
  #print(teste.group(0))

  #se não encontrou a classe anterior, existem 2 opções
  # 1 - o jogo está com desconto(possui 2 outras tags para o preço)
  # 2 - o jogo não pode ser comprado(ainda não foi lançado)
  if details == None:
    #procuramos pelo preço original, sem desconto
    details = soup.find('div', {'class','discount_original_price'})

    if details != None: #O jogo está com desconto
      #pricetag = pattern.findall(details.get_text()) #procura o preço do jogo
      #pricetag = pricetag[0]

      teste = pattern.search(details.get_text())
      if teste:
        pricetag = teste.group(0)
      else:
        pricetag = 'Indisponivel'

    else: #é considerado que não há preço, para caso ele não encontre
      pricetag = 'Indisponível'

  else:
    pricetag = pattern.findall(details.get_text()) #procura o preço do jogo
    if not pricetag:#não encontrou valor numerico, portanto é grátis
      pricetag = 'Free To Play'
    else: # encontrou valor numerico do preço do jogo
      #pricetag = pricetag[0]
      teste = pattern.search(details.get_text())
      pricetag = teste.group(0)

  return(pricetag)

# get_Price(soup)

"""# Função para obter os modos de Jogo SinglePlayer e MultiPlayer"""

#A função busca todas as tags de um jogo e em seguida procura dentre as tags
#se o jogo é Singleplayer e/ou Multiplayer
#Retorna se o jogo é Singleplayer e Multiplayer, em forma de lista
#com valores 'Sim' ou 'Não'
def get_Gamemodes(soup):

  #encontramos todas as tags do jogo
  details = soup.find('div', {'class':'glance_tags popular_tags'})
  details = details.find_all('a')

  #aglomera as tags em uma unica string
  gametags = ""
  for item in details:
    gametags += item.get_text()

  #é eliminado espaçamentos das tags para limpar o texto
  gametags = gametags.replace('\t', '').replace('\r', '')

  tags = []
  #a string sofre um split baseado em quebras de linha, criando uma lista de tags
  tags = gametags.split('\n')

  #variaveis para checar se o jogo é singleplayer e multiplayer
  single_check = 'Não'
  multi_check = 'Não'

  #Verificamos se há uma tag para Singleplayer e/ou Multiplayer
  for item in tags:
    single_test = item.find("Singleplayer")# verifica se é uma tag "Singleplayer"
    multi_test = item.find("Multiplayer")# verifica se é uma tag "Multiplayer"
    if single_test != -1: #foi encontrada a tag Singleplayer
      single_check = 'Sim'
    elif multi_test != -1: #foi encontrada a tag Multiplayer
      multi_check = 'Sim'

  return single_check, multi_check

"""# Extraindo informacoes de recomendacoes de sistema"""

#Reconhece processador da intel no texto
def formatTextProcessor(value):
  processor = ''
  res = re.compile(r'[Ii][Nn][Tt][Ee][Ll]\s([A-Za-z]*([-\s][cC][A-Za-z]*)?)\s(\d|i\d)(\s|-)(duo|\d*[Kk]|\d*)').search(value)
  if res:
    processor = ( len(res.group(0))>0 and res.group(0).replace(' ','-').upper() or '' )
  else:
    processor = "outros"
  return processor

#Converte o texto do tipo "X MB RAM" ou "X GB RAM" em numero tamanho em gigabytes
def getValueInGB(value):
  memory = ''
  mega = re.compile(r'.MB.')
  giga = re.compile(r'.GB.')

  res = mega.search(value)
  if res:
    memory = int(value.split('MB')[0])
    memory = memory/1000 #Convertendo pra GigaByte

  res = giga.search(value)
  if res:
    memory = int(value.split('GB')[0])
  return memory

#Reconhece placas de video da NVDIA em texto
def formatTextGraphic(value):
  graphics = ''
  res = re.compile(r"([Nn][Vv][iI][Dd][iI][Aa]|[Gg][Ee][Ff][Oo][Rr][Cc][Ee])\s((GTX|RTX)\s\d+|\d+|[Gg][Ee][Ff][Oo][Rr][Cc][Ee][®]*\s(GTX|RTX)\s\d+)(\s[Tt][Ii])?").search(value)
  if res:
    graphics = (len(res.group(0)) > 0 and res.group(0).replace('®','').replace(' ','-').upper() or '')
  else:
    graphics = "outros"
  return graphics

#Pega os dados dos recomendados
def getRecomendationConfig(soup: BeautifulSoup):
  processor = None
  memory = None
  graphics = None
  storage = None
   
  soup_find = soup.find('div', {'class':'game_area_sys_req_rightCol'})
  if soup_find:
    configRecomendation = soup_find.findAll('li')
    
    for row in configRecomendation:#Percorrendo as linhas das configuracoes recomendadas do html
      config = row.get_text().split(': ')
      attribute = config[0]
      value = (len(config) > 1 and config[1] or '')
      if (attribute=='Processor'):
        processor = formatTextProcessor(value)
      elif (attribute=='Memory'):
        memory = getValueInGB(value)
      elif (attribute=='Graphics'):
        graphics = formatTextGraphic(value)
      elif (attribute=='Storage'):
        storage = getValueInGB(value)
    
    return processor, memory, graphics, storage
  else:
    return None, None, None, None

"""# Extraindo quantidade de plataformas compativeis do jogo"""

def getPlatformas(soup: BeautifulSoup) -> int:
  nPlatforms = 1
  platforms = soup.findAll('div', {'class':'sysreq_tab'})#Verifica se tem mais de um sistema operacional
  nPlatforms = (len(platforms) > 0 and len(platforms) or 1)#por padrao, eh desenvolvido pelo menos pra windows
  return nPlatforms

"""# Extraindo URLs dos jogos do portal

Utilizando a funcao get_games_from_pages() conseguimos extrair todos os jogos de uma quantidade n de paginas, todas as URLs sao armazenadas na variavel **game_urls**.
"""

from bs4 import BeautifulSoup
import requests
import sys
import re
import time
import random
from bs4 import BeautifulSoup as Soup

# Url da pagina de busca da steam
# necessario adicionar um inteiro ao fim da string, indicando o numero da pagina
STEAM_SEARCH_RESULT_URL = 'https://store.steampowered.com/search/?sort_by=&sort_order=0&category1=998&price=%2C120&maxprice=120&page='

def get_games_urls(url):
  game_urls = []
  try:
    page_html = requests.get(url, cookies=cookies)
  except Exception as e:
    print(e)
  else:
    soup = Soup(page_html.text)
    for message in soup.findAll('a', {'class':'search_result_row'}):
      game_urls.append(message.get('href'))
  finally:
    print(f"Quantidade de jogos encontrados na sessao: {len(game_urls)}")
    return game_urls  

def get_games_from_pages(initial_page: int, final_page: int) -> list():
  game_urls = []
  for page in range(initial_page, final_page+1):
    print(f"\npagina {page}")
    time.sleep(random.uniform(0.5, 2.5))
    game_urls.extend(get_games_urls(STEAM_SEARCH_RESULT_URL+ str(page)))
  return game_urls

# game_urls = get_games_from_pages(10)
# print(f"\n\nEncontrado {len(game_urls)} jogos, sendo eles:\n {game_urls}")

"""# Definindo os atributos para o dataframe"""

GAME_ATTRIBUTES = [
            "Nome",
            "Desenvolvedor",
            "Distribuidora",
            "Indie",
            "Quantidade de Review",
            "Review Médio",
            "Plataforma",
            "Singleplayer",
            "Multiplayer",
            "Data de Lançamento",
            "Linguagens Interface",
            "Linguagens Dublagem",
            "Linguagens Legenda",
            "Processador",
            "Memória Ram",
            "Placa de Vídeo",
            "Espaço em Disco",
            "Preço",
        ]

"""### Funcoes uteis para escrita dos dados"""

def create_gameinfo_dict(attributes: list()) -> dict():
  return {field: None for field in attributes}

def flush_steamgames_dict(steamdict: dict()):
  for key in steamdict:
    steamdict[key] = None

"""# Extraindo informacoes dos jogos

Com as URLs criadas podemos navegar por cada pagina e extrair as informacoes que precisamos utilizando as funcoes de scrapping implementadas acima
"""

def get_gamepage_soup(game_url: str()) -> BeautifulSoup:
  soup = None
  try:
    s = requests.Session()
    page_html = s.get(game_url, cookies=cookies)
    # print(page_html.cookies)
  except Exception as e:
    print(e)
  else:
    soup = BeautifulSoup(page_html.text, 'html.parser')
  finally:
    return soup


def get_game_info(page_soup: BeautifulSoup) -> dict():
  game_info = create_gameinfo_dict(GAME_ATTRIBUTES)

  # getting all relevant infos from the game page
            # "Nome",
            # "Desenvolvedor",
            # "Distribuidora",
            # "Indie",
            # "Quantidade de Review",
            # "Review Médio",
            # "Plataforma",
            # "Singleplayer",
            # "Multiplayer",
            # "Data de Lançamento",
            # "Linguagens Interface",
            # "Linguagens Dublagem",
            # "Linguagens Legenda",
            # "Processador",
            # "Memória Ram",
            # "Placa de Vídeo",
            # "Espaço em Disco",
            # "Preço",
  game_name = get_Name(soup)
  num_platform = getPlatformas(page_soup)
  is_singleplayer, is_multiplayer = get_Gamemodes(page_soup)
  processor, memory, graphics, storage = getRecomendationConfig(page_soup)
  date, review, num_review, dev, distributor = get_Attributes(page_soup)
  is_indie = get_Indie(page_soup)
  lang_interface, lang_dub, lang_sub = get_Languages(page_soup)
  price = get_Price(page_soup)

  game_info['Nome'] = game_name
  game_info['Desenvolvedor'] = dev
  game_info['Distribuidora'] = distributor
  game_info['Indie'] = is_indie
  game_info['Quantidade de Review'] = num_review 
  game_info['Review Médio'] = review
  game_info['Plataforma'] = num_platform
  game_info['Singleplayer'] = is_singleplayer
  game_info['Multiplayer'] = is_multiplayer
  game_info['Data de Lançamento'] = date
  game_info['Linguagens Interface'] = lang_interface
  game_info['Linguagens Dublagem'] = lang_dub
  game_info['Linguagens Legenda'] = lang_sub
  game_info['Processador'] = processor
  game_info['Memória Ram'] = memory
  game_info['Placa de Vídeo'] = graphics
  game_info['Espaço em Disco'] = storage
  game_info['Preço'] = price

  return game_info

"""# **Agregando tudo**"""

import csv

 # Nome do csv 
filename = "steamgames.csv"
    
# iterando sobre as paginas e escrevendo no csv  
with open(filename, 'w') as csvfile:  
    csvwriter = csv.DictWriter(csvfile, fieldnames=GAME_ATTRIBUTES, delimiter=",")
    csvwriter.writeheader() 

    for n in range(0, 40):
      games_urls = get_games_from_pages((n*25)+1, (n*25)+25)

      for url in games_urls:
        print(url)
        try:
          soup = get_gamepage_soup(url)
          game_info = get_game_info(soup)
        except Exception as e:
          print(e)
        else:
          csvwriter.writerow(game_info)
